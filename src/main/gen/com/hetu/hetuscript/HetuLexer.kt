// Generated by JFlex 1.9.2 http://jflex.de/  (tweaked for IntelliJ platform)
// source: HetuLexer.flex
package com.hetu.hetuscript

import com.intellij.psi.tree.IElementType

internal class HetuLexer(`in`: java.io.Reader?) : FlexLexer {
    /** the input device  */
    private val zzReader: java.io.Reader?

    /** the current state of the DFA  */
    private var zzState = 0

    /** the current lexical state  */
    private var zzLexicalState: Int = com.hetu.hetuscript.HetuLexer.Companion.YYINITIAL

    /** this buffer contains the current text to be matched and is
     * the source of the yytext() string  */
    private var zzBuffer: CharSequence = ""

    /** the textposition at the last accepting state  */
    private var zzMarkedPos = 0

    /** the current text position in the buffer  */
    private var zzCurrentPos = 0

    /** startRead marks the beginning of the yytext() string in the buffer  */
    var tokenStart: Int = 0
        private set

    /** endRead marks the last character in the buffer, that has been read
     * from input  */
    private var zzEndRead = 0

    /** zzAtEOF == true <=> the scanner is at the EOF  */
    private var zzAtEOF = false

    /** Number of newlines encountered up to the start of the matched text.  */
    @SuppressWarnings("unused")
    private val yyline = 0

    /** Number of characters from the last newline up to the start of the matched text.  */
    @SuppressWarnings("unused")
    protected var yycolumn: Int = 0

    /** Number of characters up to the start of the matched text.  */
    @SuppressWarnings("unused")
    private val yychar: Long = 0

    /** Whether the scanner is currently at the beginning of a line.  */
    @SuppressWarnings("unused")
    private var zzAtBOL = true

    /** Whether the user-EOF-code has already been executed.  */
    @SuppressWarnings("unused")
    private val zzEOFDone = false


    /**
     * Creates a new scanner
     *
     * @param   in  the java.io.Reader to read input from.
     */
    init {
        this.zzReader = `in`
    }


    /** Returns the maximum size of the scanner buffer, which limits the size of tokens.  */
    private fun zzMaxBufferLen(): Int {
        return Integer.MAX_VALUE
    }

    /**  Whether the scanner buffer can grow to accommodate a larger token.  */
    private fun zzCanGrow(): Boolean {
        return true
    }

    val tokenEnd: Int
        get() = this.tokenStart + yylength()

    fun reset(buffer: CharSequence, start: Int, end: Int, initialState: Int) {
        zzBuffer = buffer
        this.tokenStart = start
        zzMarkedPos = this.tokenStart
        zzCurrentPos = zzMarkedPos
        zzAtEOF = false
        zzAtBOL = true
        zzEndRead = end
        yybegin(initialState)
    }

    /**
     * Refills the input buffer.
     *
     * @return      `false`, iff there was new input.
     *
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    @kotlin.Throws(IOException::class)
    private fun zzRefill(): Boolean {
        return true
    }


    /**
     * Returns the current lexical state.
     */
    fun yystate(): Int {
        return zzLexicalState
    }


    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    fun yybegin(newState: Int) {
        zzLexicalState = newState
    }


    /**
     * Returns the text matched by the current regular expression.
     */
    fun yytext(): CharSequence {
        return zzBuffer.subSequence(this.tokenStart, zzMarkedPos)
    }


    /**
     * Returns the character at position `pos` from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     * A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    fun yycharat(pos: Int): Char {
        return zzBuffer.charAt(this.tokenStart + pos)
    }


    /**
     * Returns the length of the matched text region.
     */
    fun yylength(): Int {
        return zzMarkedPos - this.tokenStart
    }


    /**
     * Reports an error that occurred while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the errormessage to display
     */
    private fun zzScanError(errorCode: Int) {
        var message: String?
        try {
            message = com.hetu.hetuscript.HetuLexer.Companion.ZZ_ERROR_MSG[errorCode]
        } catch (e: ArrayIndexOutOfBoundsException) {
            message =
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_ERROR_MSG[com.hetu.hetuscript.HetuLexer.Companion.ZZ_UNKNOWN_ERROR]
        }

        throw Error(message)
    }


    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     * This number must not be greater than yylength()!
     */
    fun yypushback(number: Int) {
        if (number > yylength()) zzScanError(com.hetu.hetuscript.HetuLexer.Companion.ZZ_PUSHBACK_2BIG)

        zzMarkedPos -= number
    }


    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    @kotlin.Throws(IOException::class)
    fun advance(): IElementType? {
        var zzInput: Int
        var zzAction: Int

        // cached fields:
        var zzCurrentPosL: Int
        var zzMarkedPosL: Int
        var zzEndReadL = zzEndRead
        var zzBufferL: CharSequence? = zzBuffer

        val zzTransL: IntArray = com.hetu.hetuscript.HetuLexer.Companion.ZZ_TRANS
        val zzRowMapL: IntArray = com.hetu.hetuscript.HetuLexer.Companion.ZZ_ROWMAP
        val zzAttrL: IntArray = com.hetu.hetuscript.HetuLexer.Companion.ZZ_ATTRIBUTE

        while (true) {
            zzMarkedPosL = zzMarkedPos

            zzAction = -1

            this.tokenStart = zzMarkedPosL
            zzCurrentPos = this.tokenStart
            zzCurrentPosL = zzCurrentPos

            zzState = com.hetu.hetuscript.HetuLexer.Companion.ZZ_LEXSTATE[zzLexicalState]

            // set up zzAction for empty match case:
            var zzAttributes = zzAttrL[zzState]
            if ((zzAttributes and 1) == 1) {
                zzAction = zzState
            }


            zzForAction@{
                while (true) {
                    if (zzCurrentPosL < zzEndReadL) {
                        zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL)
                        zzCurrentPosL += Character.charCount(zzInput)
                    } else if (zzAtEOF) {
                        zzInput = com.hetu.hetuscript.HetuLexer.Companion.YYEOF
                        break@zzForAction
                    } else {
                        // store back cached positions
                        zzCurrentPos = zzCurrentPosL
                        zzMarkedPos = zzMarkedPosL
                        val eof = zzRefill()
                        // get translated positions and possibly new buffer
                        zzCurrentPosL = zzCurrentPos
                        zzMarkedPosL = zzMarkedPos
                        zzBufferL = zzBuffer
                        zzEndReadL = zzEndRead
                        if (eof) {
                            zzInput = com.hetu.hetuscript.HetuLexer.Companion.YYEOF
                            break@zzForAction
                        } else {
                            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL)
                            zzCurrentPosL += Character.charCount(zzInput)
                        }
                    }
                    val zzNext = zzTransL[zzRowMapL[zzState] + com.hetu.hetuscript.HetuLexer.Companion.zzCMap(zzInput)]
                    if (zzNext == -1) break@zzForAction
                    zzState = zzNext

                    zzAttributes = zzAttrL[zzState]
                    if ((zzAttributes and 1) == 1) {
                        zzAction = zzState
                        zzMarkedPosL = zzCurrentPosL
                        if ((zzAttributes and 8) == 8) break@zzForAction
                    }
                }
            }

            // store back cached position
            zzMarkedPos = zzMarkedPosL

            if (zzInput == com.hetu.hetuscript.HetuLexer.Companion.YYEOF && this.tokenStart == zzCurrentPos) {
                zzAtEOF = true
                return null
            } else {
                when (if (zzAction < 0) zzAction else com.hetu.hetuscript.HetuLexer.Companion.ZZ_ACTION[zzAction]) {
                    1 -> {
                        return TokenType.BAD_CHARACTER
                    }

                    14 -> {}
                    2 -> {
                        return TokenType.WHITE_SPACE
                    }

                    15 -> {}
                    3 -> {
                        yybegin(com.hetu.hetuscript.HetuLexer.Companion.STRING)
                        return OPERATION_SIGN
                    }

                    16 -> {}
                    4 -> {
                        return OPERATION_SIGN
                    }

                    17 -> {}
                    5 -> {
                        return IDENTIFIER
                    }

                    18 -> {}
                    6 -> {
                        return com.hetu.hetuscript.HetuLexer.Companion.STRING
                    }

                    19 -> {}
                    7 -> {
                        yybegin(com.hetu.hetuscript.HetuLexer.Companion.YYINITIAL)
                        return com.hetu.hetuscript.HetuLexer.Companion.STRING
                    }

                    20 -> {}
                    8 -> {}
                    21 -> {}
                    9 -> {
                        yybegin(com.hetu.hetuscript.HetuLexer.Companion.COMMENT)
                    }

                    22 -> {}
                    10 -> {
                        return com.hetu.hetuscript.HetuLexer.Companion.COMMENT
                    }

                    23 -> {}
                    11 -> {
                        return KEYWORD
                    }

                    24 -> {}
                    12 -> {
                        yybegin(com.hetu.hetuscript.HetuLexer.Companion.YYINITIAL)
                        return com.hetu.hetuscript.HetuLexer.Companion.COMMENT
                    }

                    25 -> {}
                    13 -> {
                        return NUMBER
                    }

                    26 -> {}
                    else -> zzScanError(com.hetu.hetuscript.HetuLexer.Companion.ZZ_NO_MATCH)
                }
            }
        }
    }


    companion object {
        /** This character denotes the end of file  */
        val YYEOF: Int = -1

        /** initial size of the lookahead buffer  */
        private const val ZZ_BUFFERSIZE = 16384

        /** lexical states  */
        const val YYINITIAL: Int = 0
        const val STRING: Int = 2
        const val COMMENT: Int = 4

        /**
         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
         * at the beginning of a line
         * l is of the form l = 2*k, k a non negative integer
         */
        private val ZZ_LEXSTATE: IntArray? = intArrayOf(
            0, 0, 1, 1, 2, 2
        )

        /**
         * Top-level table for translating characters to character classes
         */
        private val ZZ_CMAP_TOP: IntArray = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackcmap_top()

        private val ZZ_CMAP_TOP_PACKED_0 =
            "\u0001\u0000\u0003\u0100\u0001\u0200\u0001\u0100\u0001\u0300\u0001\u0400\u0001\u0100\u0005\u0500" +
                    "\u0001\u0600\u0001\u0700\u0001\u0800\u0006\u0100\u0001\u0900\u0001\u0a00\u0001\u0b00\u0001\u0c00" +
                    "\u0001\u0d00\u0001\u0e00\u0003\u0100\u0001\u0f00\u0085\u0100\u0001\u0700\u0001\u0100\u0001\u1000" +
                    "\u0001\u1100\u0001\u1200\u0001\u1300\u002c\u0100\u0008\u1400\u001f\u0100\u0001\u0a00\u0004\u0100" +
                    "\u0001\u1500\u0008\u0100\u0001\u1600\u0002\u0100\u0001\u1700\u0001\u1800\u0001\u1300\u0001\u0100" +
                    "\u0001\u0600\u0001\u0100\u0001\u1900\u0001\u1600\u0001\u0900\u0003\u0100\u0001\u1200\u0001\u1a00" +
                    "\u004c\u0100\u0001\u1b00\u0001\u1200\u006b\u0100\u0001\u1c00\u0009\u0100\u0001\u1d00\u0001\u1300" +
                    "\u0006\u0100\u0001\u1200\u0f16\u0100"

        private fun zzUnpackcmap_top(): IntArray {
            val result = IntArray(4352)
            var offset = 0
            offset = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackcmap_top(
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_CMAP_TOP_PACKED_0,
                offset,
                result
            )
            return result
        }

        private fun zzUnpackcmap_top(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l: Int = packed.length()
            while (i < l) {
                var count: Int = packed.charAt(i++)
                val value: Int = packed.charAt(i++)
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /**
         * Second-level tables for translating characters to character classes
         */
        private val ZZ_CMAP_BLOCKS: IntArray = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackcmap_blocks()

        private val ZZ_CMAP_BLOCKS_PACKED_0 =
            "\u0008\u0000\u0001\u0001\u0001\u0002\u0002\u0003\u0001\u0004\u0001\u0003\u0012\u0000\u0001\u0005" +
                    "\u0001\u0006\u0001\u0007\u0005\u0000\u0002\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000a" +
                    "\u0001\u000c\u0001\u000d\u000a\u000e\u0001\u0000\u0001\u000f\u0001\u0006\u0001\u0010\u0001\u0006" +
                    "\u0002\u0000\u0004\u0011\u0001\u0012\u0001\u0011\u0001\u0013\u0001\u0011\u0001\u0014\u0004\u0011" +
                    "\u0001\u0015\u0003\u0011\u0001\u0016\u0001\u0017\u0001\u0018\u0006\u0011\u0001\u0019\u0001\u001a" +
                    "\u0001\u001b\u0001\u001c\u0001\u0011\u0001\u0000\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0011" +
                    "\u0001\u0020\u0001\u0021\u0001\u0011\u0001\u0022\u0001\u0023\u0001\u0011\u0001\u0024\u0001\u0025" +
                    "\u0001\u0026\u0001\u0027\u0001\u0028\u0001\u0029\u0001\u0011\u0001\u002a\u0001\u002b\u0001\u002c" +
                    "\u0001\u002d\u0001\u002e\u0001\u002f\u0001\u0030\u0002\u0011\u0001\u0031\u0001\u0000\u0001\u0032" +
                    "\u0007\u0000\u0001\u0003\u01ab\u0000\u0001\u0033\u0001\u0034\u0002\u0000\u0001\u0035\u0002\u0000" +
                    "\u0001\u0036\u0001\u0037\u0001\u0038\u0001\u0039\u0001\u003a\u0001\u0000\u0001\u003b\u0001\u0000" +
                    "\u0001\u003c\u0001\u003d\u000c\u0000\u0001\u003e\u0111\u0000\u000a\u003f\u0086\u0000\u000a\u003f" +
                    "\u00c6\u0000\u000a\u003f\u009c\u0000\u000a\u003f\u0076\u0000\u000a\u003f\u0060\u0000\u000a\u003f" +
                    "\u0076\u0000\u000a\u003f\u0046\u0000\u000a\u003f\u0116\u0000\u000a\u003f\u0046\u0000\u000a\u003f" +
                    "\u0146\u0000\u000a\u003f\u0026\u0000\u000a\u003f\u012c\u0000\u000a\u003f\u0080\u0000\u000a\u003f" +
                    "\u00a6\u0000\u000a\u003f\u0006\u0000\u000a\u003f\u00b6\u0000\u000a\u003f\u0056\u0000\u000a\u003f" +
                    "\u0086\u0000\u000a\u003f\u0006\u0000\u000a\u003f\u00ce\u0000\u0002\u0003\u01a6\u0000\u000a\u003f" +
                    "\u0026\u0000\u000a\u003f\u00c6\u0000\u000a\u003f\u0016\u0000\u000a\u003f\u0056\u0000\u000a\u003f" +
                    "\u0196\u0000\u000a\u003f\u0006\u0000\u0100\u0003\u00a0\u0000\u000a\u003f\u0086\u0000\u000a\u003f" +
                    "\u012c\u0000\u000a\u003f\u0080\u0000\u000a\u003f\u003c\u0000\u000a\u003f\u0090\u0000\u000a\u003f" +
                    "\u0076\u0000\u000a\u003f\u0066\u0000\u000a\u003f\u0086\u0000\u000a\u003f\u0046\u0000\u000a\u003f" +
                    "\u00b6\u0000\u000a\u003f\u0164\u0000\u0032\u003f\u0040\u0000\u000a\u003f\u00b6\u0000"

        private fun zzUnpackcmap_blocks(): IntArray {
            val result = IntArray(7680)
            var offset = 0
            offset = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackcmap_blocks(
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_CMAP_BLOCKS_PACKED_0,
                offset,
                result
            )
            return result
        }

        private fun zzUnpackcmap_blocks(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l: Int = packed.length()
            while (i < l) {
                var count: Int = packed.charAt(i++)
                val value: Int = packed.charAt(i++)
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Translates DFA states to action switch labels.
         */
        private val ZZ_ACTION: IntArray = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackAction()

        private val ZZ_ACTION_PACKED_0 =
            "\u0003\u0000\u0002\u0001\u0001\u0002\u0001\u0001\u0001\u0003\u0003\u0004\u000d\u0005\u0001\u0006" +
                    "\u0001\u0007\u0002\u0006\u0001\u0008\u0001\u0001\u0001\u0000\u0001\u0009\u0001\u000a\u000a\u0005" +
                    "\u0001\u000b\u0006\u0005\u0001\u0000\u0001\u000c\u0001\u000d\u0002\u0000\u000d\u0005\u0004\u0000" +
                    "\u0004\u0005\u0001\u0000\u0003\u0005\u0040\u0000"

        private fun zzUnpackAction(): IntArray {
            val result = IntArray(144)
            var offset = 0
            offset = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackAction(
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_ACTION_PACKED_0,
                offset,
                result
            )
            return result
        }

        private fun zzUnpackAction(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l: Int = packed.length()
            while (i < l) {
                var count: Int = packed.charAt(i++)
                val value: Int = packed.charAt(i++)
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /**
         * Translates a state to a row index in the transition table
         */
        private val ZZ_ROWMAP: IntArray = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackRowMap()

        private val ZZ_ROWMAP_PACKED_0 =
            "\u0000\u0000\u0000\u0040\u0000\u0080\u0000\u00c0\u0000\u0100\u0000\u0140\u0000\u0180\u0000\u00c0" +
                    "\u0000\u00c0\u0000\u01c0\u0000\u0180\u0000\u0200\u0000\u0240\u0000\u0280\u0000\u02c0\u0000\u0300" +
                    "\u0000\u0340\u0000\u0380\u0000\u03c0\u0000\u0400\u0000\u0440\u0000\u0480\u0000\u04c0\u0000\u0500" +
                    "\u0000\u00c0\u0000\u00c0\u0000\u0540\u0000\u0580\u0000\u00c0\u0000\u05c0\u0000\u0600\u0000\u00c0" +
                    "\u0000\u0640\u0000\u0680\u0000\u06c0\u0000\u0700\u0000\u0740\u0000\u0780\u0000\u07c0\u0000\u0800" +
                    "\u0000\u0840\u0000\u0880\u0000\u08c0\u0000\u0200\u0000\u0900\u0000\u0940\u0000\u0980\u0000\u09c0" +
                    "\u0000\u0a00\u0000\u0a40\u0000\u0a80\u0000\u00c0\u0000\u00c0\u0000\u0ac0\u0000\u0b00\u0000\u0b40" +
                    "\u0000\u0b80\u0000\u0bc0\u0000\u0c00\u0000\u0c40\u0000\u0c80\u0000\u0cc0\u0000\u0d00\u0000\u0d40" +
                    "\u0000\u0d80\u0000\u0dc0\u0000\u0e00\u0000\u0e40\u0000\u0e80\u0000\u0ec0\u0000\u0f00\u0000\u0f40" +
                    "\u0000\u0f80\u0000\u0fc0\u0000\u1000\u0000\u1040\u0000\u1080\u0000\u10c0\u0000\u1100\u0000\u1140" +
                    "\u0000\u1180\u0000\u11c0\u0000\u1200\u0000\u1240\u0000\u1280\u0000\u12c0\u0000\u1300\u0000\u1340" +
                    "\u0000\u1380\u0000\u13c0\u0000\u1400\u0000\u1440\u0000\u1480\u0000\u14c0\u0000\u1500\u0000\u1540" +
                    "\u0000\u1580\u0000\u15c0\u0000\u1600\u0000\u1640\u0000\u1680\u0000\u16c0\u0000\u1700\u0000\u1740" +
                    "\u0000\u1780\u0000\u17c0\u0000\u1800\u0000\u1840\u0000\u1880\u0000\u18c0\u0000\u1900\u0000\u1940" +
                    "\u0000\u1980\u0000\u19c0\u0000\u1a00\u0000\u1a40\u0000\u1a80\u0000\u1ac0\u0000\u1b00\u0000\u1b40" +
                    "\u0000\u1b80\u0000\u1bc0\u0000\u1c00\u0000\u1c40\u0000\u1c80\u0000\u1cc0\u0000\u1d00\u0000\u1d40" +
                    "\u0000\u1d80\u0000\u1dc0\u0000\u1e00\u0000\u1e40\u0000\u1e80\u0000\u1ec0\u0000\u1f00\u0000\u1f40" +
                    "\u0000\u1f80\u0000\u1fc0\u0000\u2000\u0000\u2040\u0000\u2080\u0000\u20c0\u0000\u2100\u0000\u2140"

        private fun zzUnpackRowMap(): IntArray {
            val result = IntArray(144)
            var offset = 0
            offset = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackRowMap(
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_ROWMAP_PACKED_0,
                offset,
                result
            )
            return result
        }

        private fun zzUnpackRowMap(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l: Int = packed.length() - 1
            while (i < l) {
                val high: Int = packed.charAt(i++) shl 16
                result[j++] = high or packed.charAt(i++)
            }
            return j
        }

        /**
         * The transition table of the DFA
         */
        private val ZZ_TRANS: IntArray = com.hetu.hetuscript.HetuLexer.Companion.zzUnpacktrans()

        private val ZZ_TRANS_PACKED_0 =
            "\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0004\u0002\u0006\u0001\u0007\u0001\u0008\u0005\u0009" +
                    "\u0001\u000a\u0001\u0004\u0001\u0009\u0001\u000b\u0008\u000c\u0001\u0009\u0001\u0004\u0001\u0009" +
                    "\u0001\u0004\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u000c\u0001\u0012" +
                    "\u0003\u000c\u0001\u0013\u0002\u000c\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u000c\u0001\u0017" +
                    "\u0001\u0018\u0001\u000c\u0002\u0009\u000d\u0004\u0003\u0019\u0002\u0004\u0002\u0019\u0001\u001a" +
                    "\u0011\u0019\u0001\u001b\u0001\u001c\u0025\u0019\u0009\u001d\u0001\u001e\u0036\u001d\u004e\u0000" +
                    "\u0001\u001f\u0030\u0000\u0001\u001f\u0002\u0000\u0001\u0006\u0001\u0000\u0002\u0006\u004a\u0000" +
                    "\u0001\u0009\u0038\u0000\u0001\u0020\u0003\u0000\u0001\u0021\u0040\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0014\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u000e\u000c\u0001\u0022\u0005\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u000d\u000c\u0001\u0023\u0006\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u0008\u000c\u0001\u0024\u0002\u000c\u0001\u0025\u0008\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0008\u000c\u0001\u0026\u000a\u000c\u0001\u0027\u001d\u0000\u0001\u000c" +
                    "\u0002\u0000\u0008\u000c\u0004\u0000\u0001\u0028\u0005\u000c\u0001\u0029\u0004\u000c\u0001\u002a" +
                    "\u0004\u000c\u0001\u002b\u0003\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u0004\u000c\u0001\u002c\u0004\u000c\u0001\u0027\u000a\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0010\u000c\u0001\u002d\u0003\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0003\u000c\u0001\u002e\u0010\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0010\u000c\u0001\u002f\u0003\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0005\u000c\u0001\u0030\u0007\u000c\u0001\u0031\u0006\u000c\u001d\u0000" +
                    "\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0001\u002a\u0013\u000c\u001d\u0000\u0001\u000c" +
                    "\u0002\u0000\u0008\u000c\u0004\u0000\u0005\u000c\u0001\u0032\u000e\u000c\u002b\u0000\u0001\u0033" +
                    "\u003d\u0000\u0001\u0019\u000c\u0000\u0001\u0019\u0002\u0000\u0001\u0019\u0001\u0000\u0001\u0019" +
                    "\u0013\u0000\u000d\u001d\u0001\u0034\u0032\u001d\u0001\u0000\u0001\u0035\u000a\u0000\u0001\u0036" +
                    "\u0001\u0000\u0001\u001f\u0003\u0000\u0001\u0037\u000d\u0000\u0001\u0037\u001e\u0000\u0001\u001f" +
                    "\u0003\u0021\u0002\u0000\u003b\u0021\u000e\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u000e\u000c\u0001\u0038\u0005\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u0003\u000c\u0001\u0039\u0010\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000" +
                    "\u0001\u003a\u0013\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000a\u000c" +
                    "\u0001\u003b\u0009\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000e\u000c" +
                    "\u0001\u003c\u0005\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000c\u000c" +
                    "\u0001\u003d\u0007\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0008\u000c" +
                    "\u0001\u0026\u000b\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000a\u000c" +
                    "\u0001\u003e\u0009\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000d\u000c" +
                    "\u0001\u002c\u0006\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000a\u000c" +
                    "\u0001\u003f\u0009\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0008\u000c" +
                    "\u0001\u0040\u000b\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000f\u000c" +
                    "\u0001\u0041\u0004\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000c\u000c" +
                    "\u0001\u0042\u0007\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0006\u000c" +
                    "\u0001\u0043\u000d\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0010\u000c" +
                    "\u0001\u003c\u0003\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0006\u000c" +
                    "\u0001\u0044\u000d\u000c\u0029\u0000\u0001\u0045\u0033\u0000\u0001\u0046\u0030\u0000\u0001\u0046" +
                    "\u000a\u0000\u0001\u0047\u0003\u0000\u0001\u0048\u0030\u0000\u0001\u0048\u000e\u0000\u0001\u000c" +
                    "\u0002\u0000\u0008\u000c\u0004\u0000\u0003\u000c\u0001\u0049\u0010\u000c\u001d\u0000\u0001\u000c" +
                    "\u0002\u0000\u0008\u000c\u0004\u0000\u0001\u004a\u0013\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u000e\u000c\u0001\u0043\u0005\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u000f\u000c\u0001\u004b\u0004\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0003\u000c\u0001\u002c\u0010\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u000b\u000c\u0001\u0049\u0008\u000c\u001d\u0000\u0001\u000c\u0002\u0000" +
                    "\u0008\u000c\u0004\u0000\u0001\u0040\u0013\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u0002\u000c\u0001\u002c\u0011\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u0008\u000c\u0001\u002c\u000b\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u0010\u000c\u0001\u004c\u0003\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u0003\u000c\u0001\u002a\u0010\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u000e\u000c\u0001\u002c\u0005\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u0008\u000c\u0001\u003c\u000b\u000c\u002a\u0000\u0001\u004d\u0025\u0000\u0001\u0035" +
                    "\u000c\u0000\u0001\u0046\u0003\u0000\u0001\u0037\u000d\u0000\u0001\u0037\u001e\u0000\u0001\u0046" +
                    "\u000e\u0000\u0001\u0048\u0030\u0000\u0001\u0048\u0001\u0000\u0001\u0035\u000c\u0000\u0001\u0048" +
                    "\u0030\u0000\u0001\u0048\u000e\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000d\u000c" +
                    "\u0001\u004e\u0006\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0007\u000c" +
                    "\u0001\u002c\u000c\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u0006\u000c" +
                    "\u0001\u004f\u000d\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c\u0004\u0000\u000d\u000c" +
                    "\u0001\u0050\u0006\u000c\u0014\u0000\u0001\u0051\u0048\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u000f\u000c\u0001\u002c\u0004\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u000a\u000c\u0001\u0031\u0009\u000c\u001d\u0000\u0001\u000c\u0002\u0000\u0008\u000c" +
                    "\u0004\u0000\u000a\u000c\u0001\u002c\u0009\u000c\u0014\u0000\u0001\u0052\u003f\u0000\u0001\u0053" +
                    "\u003f\u0000\u0001\u0054\u003f\u0000\u0001\u0055\u003f\u0000\u0001\u0056\u003f\u0000\u0001\u0057" +
                    "\u003f\u0000\u0001\u0058\u003f\u0000\u0001\u0059\u003f\u0000\u0001\u005a\u003f\u0000\u0001\u005b" +
                    "\u003f\u0000\u0001\u005c\u003f\u0000\u0001\u005d\u003f\u0000\u0001\u005e\u003f\u0000\u0001\u005f" +
                    "\u003f\u0000\u0001\u0060\u003f\u0000\u0001\u0061\u003f\u0000\u0001\u0062\u006b\u0000\u0001\u0063" +
                    "\u0013\u0000\u0001\u0064\u0064\u0000\u0001\u0065\u0035\u0000\u0001\u0066\u004b\u0000\u0001\u0067" +
                    "\u0040\u0000\u0001\u0068\u003c\u0000\u0001\u0069\u003c\u0000\u0001\u006a\u001d\u0000\u0001\u006b" +
                    "\u0051\u0000\u0001\u006c\u0040\u0000\u0001\u006d\u003d\u0000\u0001\u006e\u003d\u0000\u0001\u006f" +
                    "\u0040\u0000\u0001\u0070\u003d\u0000\u0001\u0071\u003b\u0000\u0001\u0072\u0035\u0000\u0001\u0073" +
                    "\u006c\u0000\u0001\u0074\u0012\u0000\u0001\u0075\u003f\u0000\u0001\u0076\u0047\u0000\u0001\u0077" +
                    "\u003f\u0000\u0001\u0078\u0037\u0000\u0001\u0079\u0073\u0000\u0001\u007a\u0044\u0000\u0001\u007b" +
                    "\u0034\u0000\u0001\u007c\u0047\u0000\u0001\u007d\u003b\u0000\u0001\u007e\u000d\u0000\u0001\u007f" +
                    "\u0077\u0000\u0001\u0080\u0038\u0000\u0001\u0081\u0043\u0000\u0001\u0082\u0039\u0000\u0001\u0083" +
                    "\u0046\u0000\u0001\u0084\u003d\u0000\u0001\u0085\u0011\u0000\u0001\u0086\u0039\u0000\u0001\u0087" +
                    "\u0072\u0000\u0001\u0088\u0043\u0000\u0001\u0089\u003e\u0000\u0001\u008a\u003e\u0000\u0001\u008b" +
                    "\u003a\u0000\u0001\u008c\u000f\u0000\u0001\u008d\u0070\u0000\u0001\u008e\u0023\u0000\u0001\u008f" +
                    "\u003f\u0000\u0001\u0090\u002c\u0000\u0001\u0019\u0038\u0000"

        private fun zzUnpacktrans(): IntArray {
            val result = IntArray(8576)
            var offset = 0
            offset = com.hetu.hetuscript.HetuLexer.Companion.zzUnpacktrans(
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_TRANS_PACKED_0,
                offset,
                result
            )
            return result
        }

        private fun zzUnpacktrans(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l: Int = packed.length()
            while (i < l) {
                var count: Int = packed.charAt(i++)
                var value: Int = packed.charAt(i++)
                value--
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /* error codes */
        private const val ZZ_UNKNOWN_ERROR = 0
        private const val ZZ_NO_MATCH = 1
        private const val ZZ_PUSHBACK_2BIG = 2

        /* error messages for the codes above */
        private val ZZ_ERROR_MSG = arrayOf<String?>(
            "Unknown internal scanner error",
            "Error: could not match input",
            "Error: pushback value was too large"
        )

        /**
         * ZZ_ATTRIBUTE[aState] contains the attributes of state `aState`
         */
        private val ZZ_ATTRIBUTE: IntArray = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackAttribute()

        private val ZZ_ATTRIBUTE_PACKED_0 =
            "\u0003\u0000\u0001\u0009\u0003\u0001\u0002\u0009\u000f\u0001\u0002\u0009\u0002\u0001\u0001\u0009" +
                    "\u0001\u0001\u0001\u0000\u0001\u0009\u0012\u0001\u0001\u0000\u0002\u0009\u0002\u0000\u000d\u0001" +
                    "\u0004\u0000\u0004\u0001\u0001\u0000\u0003\u0001\u0040\u0000"

        private fun zzUnpackAttribute(): IntArray {
            val result = IntArray(144)
            var offset = 0
            offset = com.hetu.hetuscript.HetuLexer.Companion.zzUnpackAttribute(
                com.hetu.hetuscript.HetuLexer.Companion.ZZ_ATTRIBUTE_PACKED_0,
                offset,
                result
            )
            return result
        }

        private fun zzUnpackAttribute(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l: Int = packed.length()
            while (i < l) {
                var count: Int = packed.charAt(i++)
                val value: Int = packed.charAt(i++)
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Translates raw input code points to DFA table row
         */
        private fun zzCMap(input: Int): Int {
            val offset = input and 255
            return if (offset == input) com.hetu.hetuscript.HetuLexer.Companion.ZZ_CMAP_BLOCKS[offset] else com.hetu.hetuscript.HetuLexer.Companion.ZZ_CMAP_BLOCKS[com.hetu.hetuscript.HetuLexer.Companion.ZZ_CMAP_TOP[input shr 8] or offset]
        }
    }
}
